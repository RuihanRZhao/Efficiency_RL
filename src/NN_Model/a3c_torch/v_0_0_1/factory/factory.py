# importimport torchfrom . import Database as DBfrom . import Initialize_Factory as IFfrom . import factory_util as f_funcimport numpy as np# set numpy to display without using scientific notationnp.set_printoptions(suppress=True)# Initial factory data in SQLIF.Initialize_Factory_DB()Material_List = IF.Initialize_Material()Producer_List = IF.Initialize_Producer()def get_environment(day):    if day == 0: return "Error, day 0 cannot be process."    p_info = f_func.Get_producer_table()    M_len = len(Material_List)    P_len = len(p_info)    material_info = np.zeros((5, M_len))    for i in range(M_len):        price_trend = (                              DB.Get_Material_Price(Material_List[i].name, day) -                              (DB.Get_Material_Price(Material_List[i].name,                                                     day - 3) if day >= 3 else DB.Get_Material_Price(                                  Material_List[i].name, 0))) / \                      (3 if day >= 3 else day                       )        temp = np.array([            Material_List[i].id,            Material_List[i].storage,            Material_List[i].max_storage,            DB.Get_Material_Price(Material_List[i].name, day),            round(price_trend, 4)        ])        for i1 in range(5):            material_info[i1, i] = temp[i1]    producer_info = np.zeros((3, P_len))    for i in range(P_len):        temp = np.array([            f_func.Get_Material_by_Name(p_info[i][0], Material_List).id,            f_func.Get_Material_by_Name(p_info[i][1], Material_List).id,            p_info[i][2]        ])        for i1 in range(3):            producer_info[i1, i] = temp[i1]    info = np.zeros((8, M_len if M_len > P_len else P_len), dtype=np.float32)    info[:5, :M_len] = material_info    info[5:8, :P_len] = producer_info    return infodef take_action(player_actions, day):    buy_actions = player_actions[0]    pro_actions = player_actions[1]    sel_actions = player_actions[2]    buy_rewards = []    pro_rewards = []    sel_rewards = []    buy_values = []    pro_values = []    sel_values = []    # buy    for i1 in range(len(Material_List)):        r, v = Material_List[i1].buy(int(buy_actions[i1]), day)        buy_rewards.append(r)        buy_values.append(v)    # produce    count = 0    for i1 in range(len(Producer_List)):        r, v = Producer_List[i1].produce(int(pro_actions[i1]), Material_List)        pro_rewards.append(r)        pro_values.append(v)    # sell    count = 0    for i1 in range(len(Material_List)):        r, v = Material_List[i1].sell(int(sel_actions[i1]), day)        sel_rewards.append(r)        sel_values.append(v)    r_info = np.zeros((3, get_matrix_size()), dtype=np.float32)    r_info[0, :len(buy_rewards)] = buy_rewards    r_info[1, :len(pro_rewards)] = pro_rewards    r_info[2, :len(sel_rewards)] = sel_rewards    v_info = np.zeros((3, get_matrix_size()), dtype=np.float32)    v_info[0, :len(buy_values)] = buy_values    v_info[1, :len(pro_values)] = pro_values    v_info[2, :len(sel_values)] = sel_values    return r_info, v_infodef get_matrix_size():    return DB.check_max_table_lenght()